# -*- coding: utf-8 -*-
"""DM_vsBB-8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lA3nkobOOAcbqIxjSsZh3F3KVwbGZF4Y
"""

# proba clasificar barrios baratos medios y caros por la media o mediana del precio del barrio
# ver el tema de atributos escritos

"""# Paquetes"""

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split, StratifiedShuffleSplit

import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import seaborn as sns

from datetime import datetime
import re
from pathlib import Path

from sklearn import model_selection
from sklearn import ensemble
from sklearn import metrics
from sklearn.neighbors import LocalOutlierFactor
from sklearn.preprocessing import MinMaxScaler

from scipy.spatial import cKDTree

from pathlib import Path
import geopandas as gpd
import pandas as pd
import requests, zipfile, io, os
from shapely.geometry import Point






"""# Filtro"""

#@title convierto_pesos_a_dolares
def convierto_pesos_a_dolares(df, cambio=78.5, debug=True):
    df_out =  df.copy()
    df_out["en_pesos"] = False
    en_pesos = df_out[df_out["currency"].isin(["ARS"])]
    if debug:
        print(f"Tengo {len(en_pesos)} propiedades en pesos")
    precio_dolares = en_pesos["price"] / cambio
    df_out.loc[en_pesos.index, "price"] = precio_dolares
    df_out.loc[en_pesos.index, "currency"] = "USD"
    df_out.loc[en_pesos.index, "en_pesos"] = True
    return df_out

#@title convierto_ph
def convierto_ph(df, convierto_a="Casa", debug=True):
    df_out = df.copy()
    df_out["es_PH"] = False
    phs = (df_out["property_type"] == "PH")
    if debug:
        print(f"Tengo {sum(phs)} PHs")
    if convierto_a not in ["Casa", "Departamento"]:
        raise ValueError(f"Mal convierto_a")
    df_out.loc[phs, "property_type"] = convierto_a
    df_out.loc[phs, "es_PH"] == True
    return df_out

#@title filtro_datos
def filtro_datos(df, tipo="train"):
    if tipo == "train":
        train_1 = df[df["l1"] == "Argentina"]
        train_1 = train_1[train_1["l2"] == "Capital Federal"]
        train_1 = train_1[train_1["operation_type"] == "Venta"]
        # train_1 = convierto_ph(train_1, convierto_a="Casa")
        train_1 = train_1[train_1["property_type"].isin(["Casa", "Cochera", "Departamento"])]
        train_1 = convierto_pesos_a_dolares(train_1)
        train_1 = train_1[train_1["currency"].isin(["USD"])]
        # train_1 = train_1.drop_duplicates(subset=["title", "description"])
        return train_1
    print(f"No filtro datos para df tipo {tipo}")
    return df

#@title 1- filtro_datos TRAIN
train_1 = filtro_datos(df_train, tipo="train")

"""#

# lat lon barrio

# Zonaprop
"""

#@title zonaprop
zonaprop = pd.read_csv(f"{DIR}/../INDEX_CABA_VENTA_INDEX_Table.csv")
zonaprop = zonaprop.replace('-', np.nan)
zonaprop



#@title relleno lat lons con barrio
def relleno_latlon_con_l3(df, debug=True):
    df_out = df.copy()
    df_out["corrijo_latlon"] = False
    # limites_caba
    top = -34.52472083449454
    bottom = -34.705152858356506
    left = -58.53499698292211
    right = -58.336457508528376

    lats_caba = (df_out["lat"]>bottom)&(df_out["lat"]<top)
    lons_caba = (df_out["lon"]>left)&(df_out["lon"]<right)
    en_caba = lats_caba & lons_caba
    tiene_barrio = (df_out["l3"].notna())

    # si tiene barrio pero no está en caba, pongo nan
    df_out.loc[tiene_barrio & (~lats_caba), "lat"] = np.nan
    df_out.loc[tiene_barrio & (~lons_caba), "lon"] = np.nan
    df_out.loc[tiene_barrio & (~en_caba), "corrijo_latlon"] = True

    df_bien = df_out.loc[en_caba & tiene_barrio]

    # Calculo la medi a delos barrios
    media_latlon_barrios = df_bien.groupby("l3").agg(
        mean_lat=("lat", "mean"),
        mean_lon=("lon", "mean"),
    )

    # Uno la media de los barrios segun "l3"
    df_out = df_out.merge(
        media_latlon_barrios, left_on="l3", right_index=True, how="left"
    )

    df_out.loc[(df_out["lat"].isna())|(df_out["lon"].isna()), "corrijo_latlon"] == True
    if debug:
        print(f'Tengo {sum((df_out["lat"].isna())|(df_out["lon"].isna()))} latlons mal')

    # reemplazo nans donde tenga barrio y no lat lon
    df_out["lat"] = df_out["lat"].fillna(df_out["mean_lat"])
    df_out["lon"] = df_out["lon"].fillna(df_out["mean_lon"])

    return df_out

#@title relleno barrios con latlon
def relleno_barrios_con_latlon(df, debug=True):
    df_out = df.copy()
    df_out["corrijo_barrio"] = False
    # limites_caba
    top = -34.52472083449454
    bottom = -34.705152858356506
    left = -58.53499698292211
    right = -58.336457508528376

    lats_caba = (df_out["lat"]>bottom)&(df_out["lat"]<top)
    lons_caba = (df_out["lon"]>left)&(df_out["lon"]<right)
    en_caba = lats_caba & lons_caba
    tiene_barrio = (df_out["l3"].notna())

    df_bien = df_out.loc[en_caba & tiene_barrio]

    # por las dudas me fijo todos los barrios de caba, no solo los nans
    props_en_caba = df_out.loc[en_caba].copy()

    tree = cKDTree(df_bien[["lat", "lon"]].values)
    distancias, indices = tree.query(props_en_caba[["lat", "lon"]].values, k=7)

    barrios_vecinos = df_bien["l3"].values[indices]  # array (n, 7)
    barrios_vecinos_df = pd.DataFrame(barrios_vecinos)
    if debug:
        print(barrios_vecinos_df.head())

    # Calculo la moda
    barrios_imputados = barrios_vecinos_df.mode(axis=1)[0].values

    props_en_caba["l3_imputado"] = barrios_imputados
    props_en_caba["l3_original"] = df_out.loc[en_caba, "l3"].values
    props_en_caba["barrio_modificado"] = props_en_caba["l3_imputado"] != props_en_caba["l3_original"]


    df_out.loc[props_en_caba.index, "l3"] = barrios_imputados
    df_out.loc[~tiene_barrio, "corrijo_barrio"] = True
    if debug:
        print(f'Tengo {len(props_en_caba[props_en_caba["l3"].isna()])} sin barrio')
    cambiados = props_en_caba[props_en_caba["barrio_modificado"]]
    df_out.loc[cambiados.index, "corrijo_barrio"] = True
    if debug:
        print(f"Cambie barrios en {len(cambiados)}")
        print(cambiados[["lat", "lon", "l3_original", "l3_imputado"]].head())
    return df_out

#@title barrios_con_OSM




#@title relleno_barrios_con_latlon2
def relleno_barrios_con_latlon2(df, debug=True):
    df_out = df.copy()
    # Paso 1: Descargar y descomprimir el shapefile
    url = "https://cdn.buenosaires.gob.ar/datosabiertos/datasets/ministerio-de-educacion/barrios/barrios.zip"
    response = requests.get(url)
    with zipfile.ZipFile(io.BytesIO(response.content)) as z:
        z.extractall("barrios_caba")

    # Paso 2: Leer el shapefile con geopandas
    barrios_gdf = gpd.read_file("barrios_caba/barrios.shp")

    # Paso 3: Convertir tu df de puntos en un GeoDataFrame
    gdf_puntos = gpd.GeoDataFrame(df.copy(), geometry=gpd.points_from_xy(df.lon, df.lat), crs="EPSG:4326")

    # Asegurar que ambos estén en la misma proyección
    barrios_gdf = barrios_gdf.to_crs("EPSG:4326")

    # Paso 4: Hacer un spatial join
    gdf_joined = gpd.sjoin(gdf_puntos, barrios_gdf[['nombre', 'geometry']], how="left", predicate='within')

    # Paso 5: Agregar la columna barrio al DataFrame original
    df_out = df.copy()
    df_out["barrio"] = gdf_joined["nombre"]

    return df_out

#@title corrijo latlons barrio
def corrijo_latlons_barrio(df, tipo="train", debug=True):
    df_out = df.copy()
    # primero invierto los lat lon
    df_out = invierto_lat_lon(df_out)

    # relleno lat lons nan con barrio
    df_out = relleno_latlon_con_l3(df_out)

    # pongo barrio con lat lon
    df_out = relleno_barrios_con_latlon(df_out)
    if tipo == "train":
        if debug:
            print(f'Tiro {len(df_out) - len(df_out.dropna(subset=["lat", "lon", "l3"]))} nans')
        df_out = df_out.dropna(subset=["lat", "lon", "l3"])
    return df_out

#@title 2- corrijo latlons barrio TRAIN
train_2 = corrijo_latlons_barrio(train_1, tipo="train")

#@title 2- corrijo latlons barrio TEST
test_2 = corrijo_latlons_barrio(df_test, tipo="test")

figura_barrios_geo(train_2, by="l3")


#%%
"""# Transformaciones"""


#@title aplico_transformaciones

#@title 3- aplico transformaciones
train_3 = aplico_transformaciones(transformo_props(train_2))
test_3 = aplico_transformaciones(transformo_props(test_2))

"""# Correcciones fortuitas"""

#@title correcciones de pedo
# Este es dpto
for index in [15974, 452208, 452209]:
    train_3.loc[index, "es_Casa"] = 0
    train_3.loc[index, "es_Departamento"] = 1

for index in [413623, 31798]:
    train_3.loc[index, "es_Cochera"] = 1
    train_3.loc[index, "es_Departamento"] = 0
# Tiro estas falopas
for index in [845561, 364278, 364296,583675, 857027, 221666, 32371, 32982, 206820, 346301, 617186, 364277, 994027, 49928, 111953, 758093, 88491, 15038, 846439,118250]:
    train_3 = train_3.drop(index=index)
train_3.loc[14842, "rooms"] = 13
train_3.loc[616969, "surface_total"] = 114
train_3.loc[640768, "surface_total"] = 120
train_3.loc[831195, "surface_total"] = 77
train_3.loc[88491, "surface_total"] = 126
train_3.loc[544806, "surface_covered"] = 126
train_3.loc[969228, "surface_total"] = 183
train_3.loc[276679, "l3"] = "Belgrano"
train_3.loc[[184214, 237857], "bedrooms"] = 0
train_3.loc[72997, ["rooms", "bedrooms"]] = [3, 2]
train_3.loc[782283, "surface_total"] = 69.1
train_3.loc[627201, "rooms"] = 6
train_3.loc[699889, "rooms"] = 4

test_3.loc[[34447, 43990, 63616, 173868, 191965, 191966, 191967, 233270, 315338], "rooms"] = [3, 2, 2, 2, 2, 2, 2, 2, 2]

"""# Ambientes y Superficies

## Correccion inicial
"""

#@title 4- separo por tipo de propiedad
train_4_casa = train_3[train_3["es_Casa"] == True]
train_4_dpto = train_3[train_3["es_Departamento"] == True]
train_4_coch = train_3[train_3["es_Cochera"] == True]

test_4_casa = test_3[test_3["es_Casa"] == True]
test_4_dpto = test_3[test_3["es_Departamento"] == True]
test_4_coch = test_3[test_3["es_Cochera"] == True]

"""## Datos Falopa a Nan"""

#@title mal_values_a_nan_CASA
def mal_values_a_nan_CASA(df, tipo="train", debug=True):
    indices_a_corregir = {}

    df_int = df.copy()
    print(f"Arranco con {df_int.shape}")

    ### ROOMS ###
    # Si hay alguno que tiene ambiente 0 le pongo un Nan
    sel = (df_int["rooms"]<=0)
    df_int.loc[sel, "rooms"] = np.nan
    if debug:
        print(f"Rooms <= 0:\t {sum(sel)}")

    ### BEDROOMS ###
    # Si hay alguno que tiene bedroom 0 le pongo un Nan
    sel = (df_int["bedrooms"]<=0)
    df_int.loc[sel, "bedrooms"] = np.nan
    if debug:
        print(f"bedrooms <= 0:\t {sum(sel)}")


    ### BATHROOMS ###
    # Si hay alguno que tiene bedroom 0 le pongo un Nan
    sel = (df_int["bathrooms"]<=0)
    df_int.loc[sel, "bathrooms"] = np.nan
    if debug:
        print(f"bathrooms <= 0:\t {sum(sel)}")

    ### RELACION BEDROOM BATHROOM
    sel = (df_int["bathrooms"] > df_int["bedrooms"])
    indices_a_corregir["bath_gt_bed"] = df_int[sel].index
    if debug:
        print(f"bathrooms > bedrooms:\t {sum(sel)}")

    ### REALCION BEDROOM ROOM
    sel = (df_int["bedrooms"] > df_int["rooms"])
    indices_a_corregir["bed_gt_room"] = df_int[sel].index
    if debug:
        print(f"bedrooms > rooms:\t {sum(sel)}")

    ### SUPERFICIES ###
    # Si alguno tiene superficie < 10 y no es cochera le pongo un nan
    sel = (df_int["surface_total"]<10)
    df_int.loc[sel, "surface_total"] = np.nan
    if debug:
        print(f"surface_total < 10:\t {sum(sel)}")
    sel = (df_int["surface_covered"]<10)
    df_int.loc[sel, "surface_covered"] = np.nan
    if debug:
        print(f"surface_covered < 10:\t {sum(sel)}")

    ### RELACION SUP TOT SUP COV
    # Si tengo surface_covered > surface_total
    sel = (df_int["surface_covered"] > df_int["surface_total"])
    indices_a_corregir["tot_gt_cov"] = df_int[sel].index
    if debug:
        print(f"surface_covered > surface_total:\t {sum(sel)}")

    ### PRECIOS ###
    # si alguno tiene precio = 0 o = 1 o 111111 o alguna boludez así, va Nan
    repetidos = df_int["price"].astype(str).str.match(r'^([0-8])\1+\.\d{1}$')
    ascendentes = df_int["price"].astype(str).str.match(r'^123456789?\.\d{1}$')

    if debug:
        print(f"precios falopa:\t {sum(repetidos) + sum(ascendentes)}")
    df_int.loc[repetidos | ascendentes, "price"] = np.nan
    print("\n")

    df_int = aplico_transformaciones(df_int)
    return df_int, indices_a_corregir

#@title mal_values_a_nan_DPTO
def mal_values_a_nan_DPTO(df, tipo="train", debug=True):
    indices_a_corregir = {}

    df_int = df.copy()
    print(f"Arranco con {df_int.shape}")

    ### ROOMS ###
    # Si hay alguno que tiene ambiente 0 le pongo un Nan
    sel = (df_int["rooms"]<=0)
    df_int.loc[sel, "rooms"] = np.nan
    if debug:
        print(f"Rooms <= 0:\t {sum(sel)}")

    ### BEDROOMS ###
    # Si hay alguno que tiene bedroom 0 le pongo un Nan
    sel = (df_int["bedrooms"]<0) # puede ser 0 un monoambiente
    df_int.loc[sel, "bedrooms"] = np.nan
    if debug:
        print(f"bedrooms < 0:\t {sum(sel)}")

    ### BATHROOMS ###
    # Si hay alguno que tiene bedroom 0 le pongo un Nan
    sel = (df_int["bathrooms"]<=0)
    df_int.loc[sel, "bathrooms"] = np.nan
    if debug:
        print(f"bathrooms <= 0:\t {sum(sel)}")

    ### RELACION BEDROOM BATHROOM
    sel = (df_int["bathrooms"] > df_int["bedrooms"]) & (df_int["bedrooms"]>0)
    indices_a_corregir["bath_gt_bed"] = df_int[sel].index
    if debug:
        print(f"bathrooms > bedrooms (no monoambiente):\t {sum(sel)}")

    ### REALCION BEDROOM ROOM
    sel = (df_int["bedrooms"] > df_int["rooms"])
    indices_a_corregir["bed_gt_room"] = df_int[sel].index
    if debug:
        print(f"bedrooms > rooms :\t {sum(sel)}")

    ### SUPERFICIES ###
    # Si alguno tiene superficie < 10
    sel = (df_int["surface_total"]<10)
    df_int.loc[sel, "surface_total"] = np.nan
    if debug:
        print(f"surface_total < 10:\t {sum(sel)}")
    sel = (df_int["surface_covered"]<10)
    df_int.loc[sel, "surface_covered"] = np.nan
    if debug:
        print(f"surface_covered < 10:\t {sum(sel)}")

    ### RELACION SUP TOT SUP COV
    # Si tengo surface_covered > surface_total, las invierto
    sel = (df_int["surface_covered"] > df_int["surface_total"])
    indices_a_corregir["tot_gt_cov"] = df_int[sel].index
    if debug:
        print(f"surface_covered > surface_total :\t {sum(sel)}")

    ### PRECIOS ###
    # si alguno tiene precio = 0 o = 1 o 111111 o alguna boludez así, va Nan
    repetidos = df_int["price"].astype(str).str.match(r'^([0-8])\1+\.\d{1}$')
    ascendentes = df_int["price"].astype(str).str.match(r'^123456789?\.\d{1}$')

    if debug:
        print(f"precios falopa:\t {sum(repetidos) + sum(ascendentes)}")
    df_int.loc[repetidos | ascendentes, "price"] = np.nan
    print("\n")
    df_int = aplico_transformaciones(df_int)

    return df_int, indices_a_corregir

#@title mal_values_a_nan_COCH
def mal_values_a_nan_COCH(df, debug=True):
    indices_a_corregir = {}

    df_int = df.copy()
    print(f"Arranco con {df_int.shape}")

    ### ROOMS ###
    # Si hay alguno que tiene ambiente != 1 le pongo nan
    sel = (df_int["rooms"]!=1)
    df_int.loc[sel, "rooms"] = np.nan
    if debug:
        print(f"Rooms =!1:\t {sum(sel)}")

    ### BEDROOMS ###
    # Si hay alguno que tiene bedroom != 0 le pongo nan
    sel = (df_int["bedrooms"]!=0)
    df_int.loc[sel, "bedrooms"] = np.nan
    if debug:
        print(f"bedrooms =!0:\t {sum(sel)}")

    ### BATHROOMS ###
    # Si hay alguno que tiene baño !=0 le pongo un Nan
    sel = (df_int["bathrooms"]!=0)
    df_int.loc[sel, "bathrooms"] = np.nan
    if debug:
        print(f"bathrooms =!0:\t {sum(sel)}")

    ### SUPERFICIES ###
    # Si alguno tiene superficie < 5
    sel = (df_int["surface_total"]<5)
    df_int.loc[sel, "surface_total"] = np.nan
    sel = (df_int["surface_covered"]<5)
    df_int.loc[sel, "surface_covered"] = np.nan

    if debug:
        print(f"surface_total < 5:\t {sum(sel)}")

    # Si alguno tiene superficie > 50
    sel = (df_int["surface_total"]>50)
    df_int.loc[sel, "surface_total"] = np.nan
    sel = (df_int["surface_covered"]>50)
    df_int.loc[sel, "surface_covered"] = np.nan
    if debug:
        print(f"surface_total > 50:\t {sum(sel)}")

    ### PRECIOS ###
    # si alguno tiene precio = 0 o = 1 o 111111 o alguna boludez así, va Nan
    repetidos = df_int["price"].astype(str).str.match(r'^([0-8])\1+\.\d{1}$')
    ascendentes = df_int["price"].astype(str).str.match(r'^123456789?\.\d{1}$')

    if debug:
        print(f"precios falopa:\t {sum(repetidos) + sum(ascendentes)}")
    df_int.loc[repetidos | ascendentes, "price"] = np.nan
    print("\n")
    df_int = aplico_transformaciones(df_int)

    return df_int, indices_a_corregir

#@title 5- datos malos a Nan TODOS
train_5_casa, casas_a_corregir_train = mal_values_a_nan_CASA(train_4_casa)
train_5_dpto, dptos_a_corregir_train = mal_values_a_nan_DPTO(train_4_dpto)
train_5_coch, coche_a_corregir_train = mal_values_a_nan_COCH(train_4_coch)

test_5_casa, casas_a_corregir_test = mal_values_a_nan_CASA(test_4_casa)
test_5_dpto, dptos_a_corregir_test = mal_values_a_nan_DPTO(test_4_dpto)
test_5_coch, coche_a_corregir_test = mal_values_a_nan_COCH(test_4_coch)

"""## Tiro los datos que tienen muchos Nans"""

#@title tiro_muchos_nans
def tiro_muchos_nans(df, debug=True, tol=2, columnas_relevantes=["rooms", "bedrooms", "surface_covered"]):
    df_out = df.copy()
    tmp = df_out.loc[:, columnas_relevantes]
    falopa = tmp[tmp.isna().sum(axis=1) > tol]
    if debug:
        print(f"Tiro las props donde las columnas {columnas_relevantes} tengan más de {tol} NaNs")
        print(df_out.shape)
        print(f"Tengo {len(falopa)} datos falopa")
        print(falopa[columnas_relevantes].head())
    df_out = df_out.drop(index=falopa.index)
    if debug:
        print(df_out.shape)
    return df_out

#@title 6- tiro muchos nans TODOS
train_6_casa = tiro_muchos_nans(train_5_casa, tol=3, columnas_relevantes=["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered"])
train_6_dpto = tiro_muchos_nans(train_5_dpto, tol=3, columnas_relevantes=["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered"])
train_6_coch = tiro_muchos_nans(train_5_coch, tol=1, columnas_relevantes=["surface_total", "surface_covered"])

test_6_casa = test_5_casa.copy()
test_6_dpto = test_5_dpto.copy()
test_6_coch = test_5_coch.copy()

comparo_test_train(df_train=train_6_casa, df_test=test_6_casa)

comparo_test_train(df_train=train_6_dpto, df_test=test_6_dpto)

"""## Corrijo campos

"""

#@title corrijo_surface_total_y_covered_inflado
def corrijo_surface_total_y_covered_inflado(df, indexes, tol=0.5, debug=False, low=0.025, upp=0.975):
    df_out = df.copy()
    factores = [1000, 100, 10]  # mayor a menor
    df_out["surface_totalycov_inflado"] = False

    # Calculo cuantiles por grupo
    quantiles = df_out.groupby(["rooms", "bedrooms"])[["surface_total", "surface_covered"]].quantile([low, 0.5, upp])

    for idx in indexes:
        if debug:
            print(f"\n{idx=}")
        try:
            row = df_out.loc[idx]
            r, b = row["rooms"], row["bedrooms"]
            sup_total, sup_cov = row["surface_total"], row["surface_covered"]

            if pd.notna(sup_total) and pd.notna(sup_cov) and sup_cov > 0:
                for f in factores:
                    corregido_total = False
                    corregido_covered = False

                    st_corr = sup_total / f
                    sc_corr = sup_cov / f

                    # Si tenemos cuantiles para este grupo
                    if (r, b) in quantiles.index:
                        st_low = quantiles["surface_total"].get((r, b, low), np.nan)
                        st_upp = quantiles["surface_total"].get((r, b, upp), np.nan)

                        if debug:
                            print(f"idx: {idx}, factor: {f}, st_corr: {st_corr}, low{low}-upp{upp}: {st_low}-{st_upp}")

                        # Verifico que el valor corregido caiga dentro del rango razonable
                        if pd.notna(st_low) and pd.notna(st_upp) and st_low * (1 - tol) < st_corr < st_upp * (1 + tol):
                            df_out.loc[idx, "surface_total"] = st_corr
                            df_out.loc[idx, "surface_totalycov_inflado"] = True
                            corregido_total = True
                            if debug:
                                print(f"surface_total corregido {st_corr}")

                        st_low = quantiles["surface_covered"].get((r, b, low), np.nan)
                        st_upp = quantiles["surface_covered"].get((r, b, upp), np.nan)

                        if debug:
                            print(f"idx: {idx}, factor: {f}, sc_corr: {sc_corr}, low {low} - upp {upp}: {st_low}-{st_upp}")

                        # Verifico que el valor corregido caiga dentro del rango razonable
                        if pd.notna(st_low) and pd.notna(st_upp) and st_low * (1 - tol) < sc_corr < st_upp * (1 + tol):
                            df_out.loc[idx, "surface_covered"] = sc_corr
                            df_out.loc[idx, "surface_totalycov_inflado"] = True
                            corregido_covered = True
                            if debug:
                                print(f"surface_covered corregido {sc_corr}")
                    # Si alguno de los dos fue corregido, no pruebo con más factores
                    if corregido_total or corregido_covered:
                        break
        except KeyError:
            if debug:
                print(f"Índice {idx} no está en el DataFrame. Lo salto.")
            continue

    return df_out

#@title corrijo_surface_inflado
def corrijo_surface_inflado(df, indexes, tol=0.5, surface="surface_total", debug=False):
    df_out = df.copy()
    factores = [1000, 100, 10]  # mayor a menor
    df_out[f"{surface}_inflado"] = False  # inicializa como False

    for idx in indexes:
        try:
            sup_total = df_out.loc[idx, "surface_total"]
            sup_cov = df_out.loc[idx, "surface_covered"]
            if surface == "surface_total":
                sup_mal = sup_total
            elif surface == "surface_covered":
                sup_mal = sup_cov
            else:
                raise ValueError(f"mal surface")
            if pd.notna(sup_total) and pd.notna(sup_cov) and sup_cov > 0:
                if surface == "surface_total":
                    ratio = sup_total / sup_cov
                else:
                    ratio = sup_cov /sup_total
                for f in factores:
                    if debug:
                        print(f"{idx=} - {f=} - {sup_total=:.1f} - {sup_cov=:.1f} - {ratio=:.1f}")
                        print(f"(1-tol) * f < ratio < (1+tol) * f: {(1-tol)*f} < {ratio} < {(1+tol)*f}")
                    condicion1 = (1-tol) * f < ratio < (1+tol) * f
                    if surface == "surface_total":
                        condicion2 = sup_mal/f > sup_cov
                    else:
                        condicion2 = sup_mal/f < sup_total
                    if condicion1 and condicion2 :
                        if debug:
                            print(f"{surface} corregida {sup_mal/f}\n")
                        df_out.loc[idx, surface] = sup_mal / f
                        df_out.loc[idx, f"{surface}_inflado"] = True
                        break
        except KeyError:
            print(f"Índice {idx} no está en el DataFrame. Lo salto.")
            continue

    return df_out

#@title corrijo_superficies_casa
def corrijo_superficies_casa(df, df_bueno, debug=True, inflado=True):
    df_out = df.copy()

    # aplico una funcion para corregir unos surface_totla y surface_cov cuando los dos se van a la mierda
    # malitos = (df_out["sup_x_room"] > df_bueno["sup_x_room"].quantile(1)) | (df_out["surface_total"]>2500) | (abs(df_out["total-cov"]) > df_out["surface_covered"] ) # ya esto es una guasada
    mucha_total = (df_out["surface_total"]>df_bueno["surface_total"].quantile(1))
    mucha_covered = (df_out["surface_covered"]>df_bueno["surface_covered"].quantile(1))
    if inflado:
        indices = df_out.loc[mucha_total & mucha_covered].index
        if debug:
            print(f"Tengo {sum(mucha_total)} con sup > al max de test")
            print(f"Tengo {sum(mucha_covered)} con cov > al max de test")
            print(f"Tengo total {len(indices)}")
        df_out = corrijo_surface_total_y_covered_inflado(df_out, indexes=indices, tol=0, debug=True)
        df_out = aplico_transformaciones(df_out)


    # aplico una funcion para corregir unos surface_total que son cualquiera
    mucha_tot_cov = (df_out["total-cov"]>df_bueno["total-cov"].quantile(1))
    if inflado:
        if debug:
            print(f"Tengo {sum(mucha_tot_cov)} con sup >>> cov")
        df_out = corrijo_surface_inflado(df_out, surface="surface_total", indexes=df_out.loc[mucha_tot_cov].index, debug=True)
        df_out = aplico_transformaciones(df_out)

    # aplico una funcion para corregir unos covered que son cualquiera
    mucha_cov_tot = (df_out["total-cov"]< -1*df_bueno["total-cov"].quantile(1))
    if inflado:
        if debug:
            print(f"Tengo {sum(mucha_cov_tot)} con sup <<< cov")
        df_out = corrijo_surface_inflado(df_out, surface="surface_covered", indexes=df_out.loc[mucha_cov_tot].index, debug=True)
        df_out = aplico_transformaciones(df_out)

    mucha_cov_tot = (df_out["total-cov"]< -1*df_bueno["total-cov"].quantile(1))
    # invierto las superficies que estén al reves
    df_out["inverti_sups"] = False
    invertidos = (df_out["surface_total"] < df_out["surface_covered"])
    mals = df_out[invertidos]
    if debug:
        print(f"Tengo {len(mals)} superficies invertidas")
        print(mals[["rooms", "surface_total", "surface_covered", "total-cov"]].head())

    for idx, row in mals.iterrows():
        df_out.loc[idx, ["surface_total", "surface_covered"]] = df_out.loc[idx, ["surface_covered", "surface_total"]].values
        df_out.at[idx, "inverti_sups"] = True

    df_out = aplico_transformaciones(df_out)

    return aplico_transformaciones(df_out)

ver_correlaciones(train_6_casa[["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "room-bed"]])

df_out = train_6_casa.copy()
df_out['sup_cov_bins'] = pd.qcut(df_out['surface_covered'], q=10, duplicates='drop')
df_out.groupby('sup_cov_bins')['rooms'].median()

#@title corrijo_ambientes_casa
def corrijo_ambientes_casa(df, debug=True):
    df_out = df.copy()
    if debug:
        print(f"Arranco con {df_out.shape}")
    df_bien_train = df_out[["rooms", "bedrooms", "bathrooms"]].dropna(subset=["rooms", "bedrooms", "bathrooms"])

    # rooms
    # Corrijo los rooms con la moda de los bedrooms
    moda_rooms = (
        df_bien_train
        .groupby("bedrooms")["rooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_room"] = False
    df_out.loc[df_out["rooms"].isna(), "corrijo_room"] = True
    df_out["rooms"] = df_out["rooms"].fillna(df_out["bedrooms"].map(moda_rooms))
    if debug:
        print(f"Correji rooms: {sum(df_out['corrijo_room'] == True)}")

    # hay rooms de casa = 1. los corrijo con la surface_covered
    sel = (df_out["rooms"]== 1)
    if debug:
        print(f"Corrijo rooms == 1 {sum(sel)}")
    df_out.loc[sel,  "corrijo_room"] = True
    df_out['sup_cov_bins'] = pd.qcut(df_out['surface_covered'], q=10, duplicates='drop')
    medianas = df_out.groupby('sup_cov_bins')['rooms'].median()
    def completar_room(row):
        bin_ = row['sup_cov_bins']
        return medianas.get(bin_, row['rooms'])  # usa la mediana si existe, si no deja el original

    df_out.loc[sel, 'rooms'] = df_out.loc[sel].apply(completar_room, axis=1)

    # bedrooms
    # Corrijo los bedrooms con la moda de los rooms
    moda_bedrooms = (
        df_bien_train
        .groupby("rooms")["bedrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bedroom"] = False
    df_out.loc[df_out["bedrooms"].isna(), "corrijo_bedroom"] = True
    df_out["bedrooms"] = df_out["bedrooms"].fillna(df_out["rooms"].map(moda_bedrooms))
    if debug:
        print(f"Correji bedrooms: {sum(df_out['corrijo_bedroom'] == True)}")

    # donde bed > room invierto
    df_out["invierto_bed_room"] = False
    sel = (df_out["bedrooms"] > df_out["rooms"])
    df_out.loc[sel, ["rooms", "bedrooms"]] = df_out.loc[sel, ["bedrooms", "rooms"]].values
    df_out.loc[sel, "invierto_bed_room"] = True
    if debug:
        print(f"inverti bed_room: {sum(df_out['invierto_bed_room'] == True)}")

    # donde son iguales pongo room = bed + 1
    df_out["corrijo_room_con_bed+1"] = False
    sel = (df_out["bedrooms"] == df_out["rooms"])
    df_out.loc[sel, "rooms"] = df_out.loc[sel, "bedrooms"].values + 1
    df_out.loc[sel, "corrijo_room_con_bed+1"] = True
    if debug:
        print(f"Correji room con bed +1: {sum(df_out['corrijo_room_con_bed+1'] == True)}")
    # los baños los completo con la moda los uqe pueda y si no con 1
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    moda_bathrooms = (
        df_bien_train
        .groupby("bedrooms")["bathrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bathrooms"] = False
    df_out.loc[df_out["bathrooms"].isna(), "corrijo_bathrooms"] = True
    df_out["bathrooms"] = df_out["bathrooms"].fillna(df_out["bathrooms"].map(moda_bathrooms))
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    df_out["bathrooms"] = df_out["bathrooms"].replace(np.nan, 1)
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
        print(f"Termino con {df_out.shape}")
    df_out = aplico_transformaciones(df_out)
    return df_out

"""### CASA"""

#@title 7- corrijo_superficies_casa CASA TRAIN
train_7_casa = corrijo_superficies_casa(
    df=train_6_casa,
    df_bueno=test_6_casa,
    inflado=True,
)

#@title 7- corrijo_superficies_casa CASA TEST
test_7_casa = corrijo_superficies_casa(
    df=test_6_casa,
    df_bueno=test_6_casa,
    inflado=True,
)

# #@title 8- corrijo_ambientes_casa TRAIN
# train_8_casa = corrijo_ambientes_casa(train_7_casa)

# #@title 8- corrijo_ambientes_casa TEST
# test_8_casa = corrijo_ambientes_casa(test_7_casa)

"""### DPTO"""

#@title corrijo_superficies_dpto
def corrijo_superficies_dpto(df, df_bueno, debug=True, inflado=True):
    df_out = df.copy()

    # aplico una funcion para corregir unos surface_totla y surface_cov cuando los dos se van a la mierda
    # malitos = (df_out["sup_x_room"] > df_bueno["sup_x_room"].quantile(1)) | (df_out["surface_total"]>2500) | (abs(df_out["total-cov"]) > df_out["surface_covered"] ) # ya esto es una guasada
    mucha_total = (df_out["surface_total"]>df_bueno["surface_total"].quantile(1))
    mucha_covered = (df_out["surface_covered"]>df_bueno["surface_covered"].quantile(1))
    if inflado:
        indices = df_out.loc[mucha_total & mucha_covered].index
        if debug:
            print(f"Tengo {sum(mucha_total)} con sup > al max de test")
            print(f"Tengo {sum(mucha_covered)} con cov > al max de test")
            print(f"Tengo total {len(indices)}")
        df_out = corrijo_surface_total_y_covered_inflado(df_out, indexes=indices, tol=0, debug=True)
        df_out = aplico_transformaciones(df_out)


    # aplico una funcion para corregir unos surface_total que son cualquiera
    mucha_tot_cov = (df_out["total-cov"]>df_bueno["total-cov"].quantile(1))
    if inflado:
        if debug:
            print(f"Tengo {sum(mucha_tot_cov)} con sup >>> cov")
        df_out = corrijo_surface_inflado(df_out, surface="surface_total", indexes=df_out.loc[mucha_tot_cov].index, debug=True)
        df_out = aplico_transformaciones(df_out)

    # aplico una funcion para corregir unos covered que son cualquiera
    mucha_cov_tot = (df_out["total-cov"]< -1*df_bueno["total-cov"].quantile(1))
    if inflado:
        if debug:
            print(f"Tengo {sum(mucha_cov_tot)} con sup <<< cov")
        df_out = corrijo_surface_inflado(df_out, surface="surface_covered", indexes=df_out.loc[mucha_cov_tot].index, debug=True)
        df_out = aplico_transformaciones(df_out)

    mucha_cov_tot = (df_out["total-cov"]< -1*df_bueno["total-cov"].quantile(1))
    # invierto las superficies que estén al reves
    df_out["inverti_sups"] = False
    invertidos = (df_out["surface_total"] < df_out["surface_covered"])
    mals = df_out[invertidos]
    if debug:
        print(f"Tengo {len(mals)} superficies invertidas")
        print(mals[["rooms", "surface_total", "surface_covered", "total-cov"]].head())

    for idx, row in mals.iterrows():
        df_out.loc[idx, ["surface_total", "surface_covered"]] = df_out.loc[idx, ["surface_covered", "surface_total"]].values
        df_out.at[idx, "inverti_sups"] = True

    df_out = aplico_transformaciones(df_out)

    return aplico_transformaciones(df_out)

#@title corrijo_ambientes_dpto
def corrijo_ambientes_dpto(df, debug=True):
    df_out = df.copy()
    if debug:
        print(f"Arranco con {df_out.shape}")
    df_bien_train = df_out[["rooms", "bedrooms", "bathrooms"]].dropna(subset=["rooms", "bedrooms", "bathrooms"])

    # rooms
    # Corrijo los rooms con la moda de los bedrooms
    moda_rooms = (
        df_bien_train
        .groupby("bedrooms")["rooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_room"] = False
    df_out.loc[df_out["rooms"].isna(), "corrijo_room"] = True
    df_out["rooms"] = df_out["rooms"].fillna(df_out["bedrooms"].map(moda_rooms))
    if debug:
        print(f"Correji rooms: {sum(df_out['corrijo_room'] == True)}")

    # bedrooms
    # Corrijo los bedrooms con la moda de los rooms
    moda_bedrooms = (
        df_bien_train
        .groupby("rooms")["bedrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bedroom"] = False
    df_out.loc[df_out["bedrooms"].isna(), "corrijo_bedroom"] = True
    df_out["bedrooms"] = df_out["bedrooms"].fillna(df_out["rooms"].map(moda_bedrooms))
    if debug:
        print(f"Correji bedrooms: {sum(df_out['corrijo_bedroom'] == True)}")

    # donde bed > room invierto
    df_out["invierto_bed_room"] = False
    sel = (df_out["bedrooms"] > df_out["rooms"])
    df_out.loc[sel, ["rooms", "bedrooms"]] = df_out.loc[sel, ["rooms", "bedrooms"]].values
    df_out.loc[sel, "invierto_bed_room"] = True
    if debug:
        print(f"inverti bed_room: {sum(df_out['invierto_bed_room'] == True)}")

    # donde son iguales pongo room = bed + 1
    df_out["corrijo_room_con_bed+1"] = False
    sel = (df_out["bedrooms"] == df_out["rooms"])
    df_out.loc[sel, "rooms"] = df_out.loc[sel, "bedrooms"].values + 1
    df_out.loc[sel, "corrijo_room_con_bed+1"] = True
    if debug:
        print(f"Correji room con bed +1: {sum(df_out['corrijo_room_con_bed+1'] == True)}")

    # los baños los completo con la moda los uqe pueda y si no con 1
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    moda_bathrooms = (
        df_bien_train
        .groupby("bedrooms")["bathrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bathrooms"] = False
    df_out.loc[df_out["bathrooms"].isna(), "corrijo_bathrooms"] = True
    df_out["bathrooms"] = df_out["bathrooms"].fillna(df_out["bathrooms"].map(moda_bathrooms))
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    df_out["bathrooms"] = df_out["bathrooms"].replace(np.nan, 1)
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
        print(f"Termino con {df_out.shape}")

    # los monoambientes pongo 1 0 1
    df_out["corrijo_monoambiente"] = (df_out["rooms"] == 1) & ((df_out["bedrooms"] != 0) | (df_out["bathrooms"] != 1))
    df_out.loc[df_out["corrijo_monoambiente"], ["rooms", "bedrooms", "bathrooms"]] = [1, 0, 1]

    df_out = aplico_transformaciones(df_out)
    return df_out

#@title 7- corrijo_superficies_dpto DPTO TRAIN
train_7_dpto = corrijo_superficies_dpto(
    df=train_6_dpto,
    df_bueno=test_6_dpto,
    inflado=True,
    debug=False,
)

#@title 7- corrijo_superficies_dpto DPTO TEST
test_7_dpto = corrijo_superficies_dpto(
    df=test_6_dpto,
    df_bueno=test_6_dpto,
    inflado=True,
)

# #@title 8- corrijo_ambientes_dpto TRAIN
# train_8_dpto = corrijo_ambientes_dpto(train_7_dpto)

# #@title 8- corrijo_ambientes_dpto TEST
# test_8_dpto = corrijo_ambientes_dpto(test_7_dpto)

"""### Cocheras"""

train_7_coch = train_6_coch.copy()
test_7_coch = test_6_coch.copy()

"""## Imputaciones

### rooms, bedrooms, bathrooms
"""

#@title imputo_ambientes_casa
def imputo_ambientes_casa(df, df_bien, debug=True):
    df_out = df.copy()
    if debug:
        print(f"Arranco con {df_out.shape}")
    df_bien = df_bien[["rooms", "bedrooms", "bathrooms"]].dropna(subset=["rooms", "bedrooms", "bathrooms"])

    # rooms
    # Corrijo los rooms con la moda de los bedrooms
    moda_rooms = (
        df_bien
        .groupby("bedrooms")["rooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_room"] = False
    df_out.loc[df_out["rooms"].isna(), "corrijo_room"] = True
    df_out["rooms"] = df_out["rooms"].fillna(df_out["bedrooms"].map(moda_rooms))
    if debug:
        print(f"Correji rooms: {sum(df_out['corrijo_room'] == True)}")

    # hay rooms de casa = 1. los corrijo con la surface_covered
    sel = (df_out["rooms"]== 1)
    if debug:
        print(f"Corrijo rooms == 1 {sum(sel)}")
    df_out.loc[sel,  "corrijo_room"] = True
    df_out['sup_cov_bins'] = pd.qcut(df_out['surface_covered'], q=10, duplicates='drop')
    medianas = df_out.groupby('sup_cov_bins')['rooms'].median()
    def completar_room(row):
        bin_ = row['sup_cov_bins']
        return medianas.get(bin_, row['rooms'])  # usa la mediana si existe, si no deja el original

    df_out.loc[sel, 'rooms'] = df_out.loc[sel].apply(completar_room, axis=1)

    # bedrooms
    # Corrijo los bedrooms con la moda de los rooms
    moda_bedrooms = (
        df_bien
        .groupby("rooms")["bedrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bedroom"] = False
    df_out.loc[df_out["bedrooms"].isna(), "corrijo_bedroom"] = True
    df_out["bedrooms"] = df_out["bedrooms"].fillna(df_out["rooms"].map(moda_bedrooms))
    if debug:
        print(f"Correji bedrooms: {sum(df_out['corrijo_bedroom'] == True)}")

    # donde bed > room invierto
    df_out["invierto_bed_room"] = False
    sel = (df_out["bedrooms"] > df_out["rooms"])
    df_out.loc[sel, ["rooms", "bedrooms"]] = df_out.loc[sel, ["bedrooms", "rooms"]].values
    df_out.loc[sel, "invierto_bed_room"] = True
    if debug:
        print(f"inverti bed_room: {sum(df_out['invierto_bed_room'] == True)}")

    # donde son iguales pongo room = bed + 1
    df_out["corrijo_room_con_bed+1"] = False
    sel = (df_out["bedrooms"] == df_out["rooms"])
    df_out.loc[sel, "rooms"] = df_out.loc[sel, "bedrooms"].values + 1
    df_out.loc[sel, "corrijo_room_con_bed+1"] = True
    if debug:
        print(f"Correji room con bed +1: {sum(df_out['corrijo_room_con_bed+1'] == True)}")
    # los baños los completo con la moda los uqe pueda y si no con 1
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    moda_bathrooms = (
        df_bien
        .groupby("bedrooms")["bathrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bathrooms"] = False
    df_out.loc[df_out["bathrooms"].isna(), "corrijo_bathrooms"] = True
    df_out["bathrooms"] = df_out["bathrooms"].fillna(df_out["bathrooms"].map(moda_bathrooms))
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    df_out["bathrooms"] = df_out["bathrooms"].replace(np.nan, 1)
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
        print(f"Termino con {df_out.shape}")
    df_out = aplico_transformaciones(df_out)
    return df_out

#@title 8- imputo_ambientes_casa TRAIN
train_8_casa = imputo_ambientes_casa(train_7_casa, df_bien=pd.concat([train_7_casa, test_7_casa]))

#@title 8- imputo_ambientes_casa TEST
test_8_casa = imputo_ambientes_casa(test_7_casa, df_bien=pd.concat([train_7_casa, test_7_casa]))

#@title imputo_ambientes_dpto
def imputo_ambientes_dpto(df, df_bien, debug=True):
    df_out = df.copy()
    if debug:
        print(f"Arranco con {df_out.shape}")
    df_bien = df_bien[["rooms", "bedrooms", "bathrooms"]].dropna(subset=["rooms", "bedrooms", "bathrooms"])

    # rooms
    # Corrijo los rooms con la moda de los bedrooms
    moda_rooms = (
        df_bien
        .groupby("bedrooms")["rooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_room"] = False
    df_out.loc[df_out["rooms"].isna(), "corrijo_room"] = True
    df_out["rooms"] = df_out["rooms"].fillna(df_out["bedrooms"].map(moda_rooms))
    if debug:
        print(f"Correji rooms: {sum(df_out['corrijo_room'] == True)}")

    # bedrooms
    # Corrijo los bedrooms con la moda de los rooms
    moda_bedrooms = (
        df_bien
        .groupby("rooms")["bedrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bedroom"] = False
    df_out.loc[df_out["bedrooms"].isna(), "corrijo_bedroom"] = True
    df_out["bedrooms"] = df_out["bedrooms"].fillna(df_out["rooms"].map(moda_bedrooms))
    if debug:
        print(f"Correji bedrooms: {sum(df_out['corrijo_bedroom'] == True)}")

    # donde bed > room invierto
    df_out["invierto_bed_room"] = False
    sel = (df_out["bedrooms"] > df_out["rooms"])
    df_out.loc[sel, ["rooms", "bedrooms"]] = df_out.loc[sel, ["rooms", "bedrooms"]].values
    df_out.loc[sel, "invierto_bed_room"] = True
    if debug:
        print(f"inverti bed_room: {sum(df_out['invierto_bed_room'] == True)}")

    # donde son iguales pongo room = bed + 1
    df_out["corrijo_room_con_bed+1"] = False
    sel = (df_out["bedrooms"] == df_out["rooms"])
    df_out.loc[sel, "rooms"] = df_out.loc[sel, "bedrooms"].values + 1
    df_out.loc[sel, "corrijo_room_con_bed+1"] = True
    if debug:
        print(f"Correji room con bed +1: {sum(df_out['corrijo_room_con_bed+1'] == True)}")

    # los baños los completo con la moda los uqe pueda y si no con 1
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    moda_bathrooms = (
        df_bien
        .groupby("bedrooms")["bathrooms"]
        .agg(lambda x: x.mode().iloc[0] if not x.mode().empty else np.nan)
    )
    df_out["corrijo_bathrooms"] = False
    df_out.loc[df_out["bathrooms"].isna(), "corrijo_bathrooms"] = True
    df_out["bathrooms"] = df_out["bathrooms"].fillna(df_out["bathrooms"].map(moda_bathrooms))
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
    df_out["bathrooms"] = df_out["bathrooms"].replace(np.nan, 1)
    if debug:
        print(f'tengo bathroms nans {df_out["bathrooms"].isna().sum()}')
        print(f"Termino con {df_out.shape}")

    # los monoambientes pongo 1 0 1
    df_out["corrijo_monoambiente"] = (df_out["rooms"] == 1) & ((df_out["bedrooms"] != 0) | (df_out["bathrooms"] != 1))
    df_out.loc[df_out["corrijo_monoambiente"], ["rooms", "bedrooms", "bathrooms"]] = [1, 0, 1]

    df_out = aplico_transformaciones(df_out)
    return df_out

#@title 8- imputo_ambientes_dpto TRAIN
train_8_dpto = imputo_ambientes_dpto(train_7_dpto, df_bien=pd.concat([train_7_dpto, test_7_dpto]))

#@title 8- imputo_ambientes_dpto test
test_8_dpto = imputo_ambientes_dpto(test_7_dpto, df_bien=pd.concat([train_7_dpto, test_7_dpto]))

#@title 8- imputo COCHERA TRAIN
# le pongo 0 a todo
train_8_coch = train_7_coch.copy()
train_8_coch.loc[:, "rooms"] = 1
train_8_coch.loc[:, "bedrooms"] = 0
train_8_coch.loc[:, "bathrooms"] = 0

#@title 8- imputo COCHERA TEST
# le pongo 0 a todo
test_8_coch = test_7_coch.copy()
test_8_coch.loc[:, "rooms"] = 1
test_8_coch.loc[:, "bedrooms"] = 0
test_8_coch.loc[:, "bathrooms"] = 0

"""### surface_total, surface_covered"""

#@title imputo_casa_sfc
def imputo_casa_sfc(df, debug=True, tipo="train"):
    """ Hago lo que hice en la entrega bien, después vemos """
    df_out = df.copy()
    print(f"Arranco con {df_out.shape}")
    # Si no tengo superficie total tomo la superficie covered
    if debug:
        nans = sum(df_out["surface_total"].isna())
        print(f"Tengo {nans} surface_total nan")
    df_out["imputo_surface_total"] = df_out["surface_total"].isna()
    df_out["surface_total"] = df_out["surface_total"].fillna(df_out["surface_covered"])

    # Si no tengo surface_covered tomo la surface_total
    if debug:
        nans = sum(df_out["surface_covered"].isna())
        print(f"Tengo {nans} surface_covered nan")
    df_out["imputo_surface_covered"] = df_out["surface_covered"].isna()
    df_out["surface_covered"] = df_out["surface_covered"].fillna(df_out["surface_total"])
    # Si no tengo ninguna los tiro a la mierda
    if tipo=="train":
        if debug:
            nans = ((df_out["surface_covered"].isna()) & (df_out["surface_total"].isna())).sum()
            print(f"Tengo {nans} surface_covered y surface_total nan")
        df_out = df_out.dropna(subset=["surface_total", "surface_covered"])

    # Si tengo surface_covered > surface_total, las invierto
    # # invierto las superficies que estén al reves
    # df_out["inverti_sups"] = False
    # invertidos = (df_out["surface_total"] < df_out["surface_covered"])
    # mals = df_out[invertidos]
    # if debug:
    #     print(f"Tengo {len(mals)} superficies invertidas")
    #     print(mals[["rooms", "surface_total", "surface_covered", "total-cov"]].head())

    # for idx, row in mals.iterrows():
    #     df_out.loc[idx, ["surface_total", "surface_covered"]] = df_out.loc[idx, ["surface_covered", "surface_total"]].values
    #     df_out.at[idx, "inverti_sups"] = True
    print(f"Termino con {df_out.shape}")
    return df_out

#@title 9- imputo SFC CASA TRAIN
train_9_casa = imputo_casa_sfc(train_8_casa, tipo="train")

#@title 9- imputo SFC CASA TEST
test_9_casa = imputo_casa_sfc(test_8_casa, tipo="test")

#@title imputo_dpto_sfc
def imputo_dpto_sfc(df, debug=True, tipo="train"):
    """ Hago lo que hice en la entrega bien, después vemos """
    df_out = df.copy()
    print(f"Arranco con {df_out.shape}")
    # Si no tengo superficie total tomo la superficie covered
    if debug:
        nans = sum(df_out["surface_total"].isna())
        print(f"Tengo {nans} surface_total nan")
    df_out["surface_total"] = df_out["surface_total"].fillna(df_out["surface_covered"])
    # Si no tengo surface_covered tomo la surface_total
    if debug:
        nans = sum(df_out["surface_covered"].isna())
        print(f"Tengo {nans} surface_covered nan")
    df_out["surface_covered"] = df_out["surface_covered"].fillna(df_out["surface_total"])
    # Si no tengo ninguna los tiro a la mierda
    if tipo=="train":
        if debug:
            nans = ((df_out["surface_covered"].isna()) & (df_out["surface_total"].isna())).sum()
            print(f"Tengo {nans} surface_covered y surface_total nan")
        df_out = df_out.dropna(subset=["surface_total", "surface_covered"])

    # Si tengo surface_covered > surface_total, las invierto
    # # invierto las superficies que estén al reves
    # df_out["inverti_sups"] = False
    # invertidos = (df_out["surface_total"] < df_out["surface_covered"])
    # mals = df_out[invertidos]
    # if debug:
    #     print(f"Tengo {len(mals)} superficies invertidas")
    #     print(mals[["rooms", "surface_total", "surface_covered", "total-cov"]].head())

    # for idx, row in mals.iterrows():
    #     df_out.loc[idx, ["surface_total", "surface_covered"]] = df_out.loc[idx, ["surface_covered", "surface_total"]].values
    #     df_out.at[idx, "inverti_sups"] = True
    print(f"Termino con {df_out.shape}")
    return df_out

#@title 9- imputo SFC DPTO TRAIN
train_9_dpto = imputo_dpto_sfc(train_8_dpto, tipo="train")

#@title 9- imputo SFC DPTO TEST
test_9_dpto = imputo_dpto_sfc(test_8_dpto, tipo="test")
nans_x_columna(test_9_dpto)

#@title imputo_coch_sfc
def imputo_coch_sfc(df, debug=True, tipo="train"):
    """ Hago lo que hice en la entrega bien, después vemos """
    df_out = df.copy()
    print(f"Arranco con {df_out.shape}")
    # Si no tengo superficie total tomo la superficie covered
    if debug:
        nans = sum(df_out["surface_total"].isna())
        print(f"Tengo {nans} surface_total nan")
    df_out["surface_total"] = df_out["surface_total"].fillna(df_out["surface_covered"])
    # Si no tengo surface_covered tomo la surface_total
    if debug:
        nans = sum(df_out["surface_covered"].isna())
        print(f"Tengo {nans} surface_covered nan")
    df_out["surface_covered"] = df_out["surface_covered"].fillna(df_out["surface_total"])
    # Si no tengo ninguna los tiro a la mierda
    if tipo=="train":
        if debug:
            nans = ((df_out["surface_covered"].isna()) & (df_out["surface_total"].isna())).sum()
            print(f"Tengo {nans} surface_covered y surface_total nan")
        df_out = df_out.dropna(subset=["surface_total", "surface_covered"])

    # Si tengo surface_covered > surface_total, las invierto
    sfc_mal = (df_out["surface_covered"] > df_out["surface_total"])
    if debug:
        nans = sum(df_out["surface_covered"] > df_out["surface_total"])
        print(f"Tengo {nans} surface_covered > surface_total ")
    df_out.loc[sfc_mal, ["surface_total", "surface_covered"]] = df_out.loc[sfc_mal, ["surface_covered", "surface_total"]].values
    print(f"Termino con {df_out.shape}")
    return df_out

#@title 9- imputo SFC coch TRAIN
train_9_coch = imputo_coch_sfc(train_8_coch, tipo="train")

#@title 9- imputo SFC coch test
test_9_coch = imputo_coch_sfc(test_8_coch, tipo="test")

comparo_test_train(train_9_casa, test_9_casa)

"""## Outliers

### CASA
"""

test_9_casa.columns

test_9_casa[["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "total-cov", "room-bed", "sfc_x_bath"]].describe()

train_9_casa[["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "total-cov", "room-bed", "sfc_x_bath"]].describe()

#@title 10- tiro_outliers_casa
def tiro_outliers_casa(df, df_test, columnas=["rooms", "bedrooms", "surface_total"], debug=True):
    df_out = df.copy()
    print(f"Arranco con {df_out.shape}")
    minmaxs = {
        "rooms": [2, df_test["rooms"].max()],
        "bedrooms": [1, df_test["bedrooms"].max()],
        "bathrooms": [1, df_test["bathrooms"].max()],
        "surface_total": [30, df_test["surface_total"].max()],
        "surface_covered": [20, df_test["surface_covered"].max()],
        "sup_x_room": [15, df_test["sup_x_room"].max()],
        "total-cov": [0, df_test["total-cov"].max()],
        "room-bed": [1, df_test["room-bed"].max()],
        "sfc_x_bath" : [20, df_test["sfc_x_bath"].max()]
    }
    if debug:
        print(f"Propiedades que no entran en los rangos establecidos\n")
        for col in columnas:
            print(f"{col}: {len(df_out[(df_out[col]<minmaxs[col][0]) | (df_out[col]>minmaxs[col][1])])}")
    for col in columnas:
        df_out = df_out[(df_out[col]>=minmaxs[col][0]) & (df_out[col]<=minmaxs[col][1])]

    df_out = aplico_transformaciones(df_out)
    print(f"Termino con {df_out.shape}")
    return df_out

train_10_casa = tiro_outliers_casa(train_9_casa, test_9_casa, columnas=["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "total-cov", "room-bed", "sfc_x_bath"])
# train_10_casa = train_9_casa.copy()

comparo_test_train(train_10_casa, test_9_casa)

"""### DPTO"""

test_9_dpto[["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "total-cov", "room-bed", "sfc_x_bath"]].describe()

train_9_dpto[["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "total-cov", "room-bed", "sfc_x_bath"]].describe()

#@title 10- tiro_outliers_dpto
def tiro_outliers_dpto(df, df_test, columnas=["rooms", "bedrooms", "surface_total"], debug=True):
    df_out = df.copy()
    print(f"Arranco con {df_out.shape}")
    minmaxs = {
        "rooms": [2, df_test["rooms"].max()],
        "bedrooms": [1, df_test["bedrooms"].max()],
        "bathrooms": [1, df_test["bathrooms"].max()],
        "surface_total": [30, df_test["surface_total"].max()],
        "surface_covered": [20, df_test["surface_covered"].max()],
        "sup_x_room": [15, df_test["sup_x_room"].max()],
        "total-cov": [0, df_test["total-cov"].max()],
        "room-bed": [1, df_test["room-bed"].max()],
        "sfc_x_bath" : [20, df_test["sfc_x_bath"].max()]
    }
    if debug:
        print(f"Propiedades que no entran en los rangos establecidos\n")
        for col in columnas:
            print(f"{col}: {len(df_out[(df_out[col]<minmaxs[col][0]) | (df_out[col]>minmaxs[col][1])])}")
    for col in columnas:
        df_out = df_out[(df_out[col]>=minmaxs[col][0]) & (df_out[col]<=minmaxs[col][1])]

    df_out = aplico_transformaciones(df_out)
    print(f"Termino con {df_out.shape}")
    return df_out

train_10_dpto = tiro_outliers_dpto(train_9_dpto, test_9_dpto, columnas=["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "sup_x_room", "total-cov", "room-bed", "sfc_x_bath"])
# train_10_dpto = train_9_dpto.copy()

"""### Cocheras"""

#@title 10- tiro_outliers_coch
def tiro_outliers_coch(df, df_test, columnas=["rooms", "bedrooms", "surface_total"], debug=True):
    df_out = df.copy()
    print(f"Arranco con {df_out.shape}")
    minmaxs = {
        "rooms": [2, df_test["rooms"].max()],
        "bedrooms": [1, df_test["bedrooms"].max()],
        "bathrooms": [1, df_test["bathrooms"].max()],
        "surface_total": [30, df_test["surface_total"].max()],
        "surface_covered": [20, df_test["surface_covered"].max()],
        "sup_x_room": [15, df_test["sup_x_room"].max()],
        "total-cov": [0, df_test["total-cov"].max()],
        "room-bed": [1, df_test["room-bed"].max()],
        "sfc_x_bath" : [20, df_test["sfc_x_bath"].max()]
    }
    if debug:
        print(f"Propiedades que no entran en los rangos establecidos\n")
        for col in columnas:
            print(f"{col}: {len(df_out[(df_out[col]<minmaxs[col][0]) | (df_out[col]>minmaxs[col][1])])}")
    for col in columnas:
        df_out = df_out[(df_out[col]>=minmaxs[col][0]) & (df_out[col]<=minmaxs[col][1])]

    df_out = aplico_transformaciones(df_out)
    print(f"Termino con {df_out.shape}")
    return df_out

train_10_coch = train_9_coch.copy()

"""# Precio

## Precios x Mts²
"""

#@title precio_xmxbxp

def precio_xmxbxp(df_train, df_test, by="l3", tipo="train", debug=True):

    df_out = df_train.copy()
    # Filtramos filas válidas para el cálculo del precio/m2
    validos = df_out["surface_covered"] > 0
    df_validos = df_out[validos].copy()
    df_validos["precio_m2"] = df_validos["price"] / df_validos["surface_covered"]

    precio_x_m2_prom = df_validos.groupby([by, "property_type"])[
        "precio_m2"
    ].mean()

    precio_x_m2_std = df_validos.groupby([by, "property_type"])[
        "precio_m2"
    ].std()

    df_out["precio_xmxbxp"] = df_out.set_index(
        [by, "property_type"]
    ).index.map(precio_x_m2_prom)

    df_out["precio_xmxbxp_std"] = df_out.set_index(
        [by, "property_type"]
    ).index.map(precio_x_m2_std)

    # Sao el precio_xmxbxp para meterlo en el test
    pxm2xbxp = df_out["precio_xmxbxp"].unique()

    # Si el precio es NaN lo imputo con surface_covered * precio_x_m2_x_barrio_x_prop
    df_out["price"] = df_out["price"].fillna(df_out["surface_covered"]*df_out["precio_xmxbxp"])
    df_out.loc[df_validos.index, "precio_m2"] = df_validos["precio_m2"]

    if tipo == "test":
        barrios_precios = df_out[[by, "property_type", "precio_xmxbxp", "precio_xmxbxp_std"]].dropna()
        barrios_precios = barrios_precios.drop_duplicates(
            subset=[by, "property_type"]
        )

        test_out = df_test.copy()
        if "precio_xmxbxp" in test_out.columns:
            test_out = test_out.drop(columns="precio_xmxbxp")
        if "precio_xmxbxp_std" in test_out.columns:
            test_out = test_out.drop(columns="precio_xmxbxp_std")

        test_out_index = test_out.index
        test_out = test_out.merge(
            barrios_precios, on=[by, "property_type"], how="left"
        ).set_index(test_out_index)
        return test_out

    if debug:
        print(df_out.groupby(by)["precio_m2"].describe())

    return df_out

#@title precio_xmxbxp2

def precio_xmxbxp2(df_train, df_test, tipo="train", debug=True):

    df_out = df_train.copy()
    df_out['precio_xmxbxp'] = np.nan
    df_out["precio_m2"] = df_out["price"] / df_out["surface_covered"]

    kf = KFold(n_splits=5, shuffle=True, random_state=42)

    for train_idx, val_idx in kf.split(df_out):
        train = df_out.iloc[train_idx]
        val = df_out.iloc[val_idx]

        # calculo media solo con el fold de entrenamiento
        media_por_barrio = train.groupby('l3')['precio_m2'].mean()
        std_por_barrio = train.groupby('l3')['precio_m2'].std()

        # mapeo al fold de validación
        df_out.loc[val.index, 'precio_xmxbxp'] = val['l3'].map(media_por_barrio)
        df_out.loc[val.index, 'precio_xmxbxp_std'] = val['l3'].map(std_por_barrio)

    # Si algún barrio no aparece en el train de un fold (raro, pero puede pasar):
    # se reemplaza con el promedio general
    df_out['precio_xmxbxp'].fillna(df_out['precio_m2'].mean(), inplace=True)
    df_out['precio_xmxbxp_std'].fillna(df_out['precio_m2'].std(), inplace=True)

    if tipo == "test":
        barrios_precios = df_out[["l3", "property_type", "precio_xmxbxp", "precio_xmxbxp_std"]].dropna()
        barrios_precios = barrios_precios.drop_duplicates(
            subset=["l3", "property_type"]
        )

        test_out = df_test.copy()
        if "precio_xmxbxp" in test_out.columns:
            test_out = test_out.drop(columns="precio_xmxbxp")
        if "precio_xmxbxp_std" in test_out.columns:
            test_out = test_out.drop(columns="precio_xmxbxp_std")

        test_out_index = test_out.index
        test_out = test_out.merge(
            barrios_precios, on=["l3", "property_type"], how="left"
        ).set_index(test_out_index)
        return test_out

    if debug:
        print(df_out.groupby("l3")["precio_m2"].describe())

    return df_out

#@title 11- precio x mt2 x l3 x propiedad TRAIN

train_11_casa = precio_xmxbxp(df_train=train_10_casa, df_test=test_9_casa, by="l3", tipo="train")
test_11_casa = precio_xmxbxp(df_train=train_10_casa, df_test=test_9_casa, by="l3", tipo="test")

train_11_dpto = precio_xmxbxp(df_train=train_10_dpto, df_test=test_9_dpto, by="l3", tipo="train")
test_11_dpto = precio_xmxbxp(df_train=train_10_dpto, df_test=test_9_dpto, by="l3", tipo="test")

train_11_coch = precio_xmxbxp(df_train=train_10_coch, df_test=test_9_coch, by="l3", tipo="train")
test_11_coch = precio_xmxbxp(df_train=train_10_coch, df_test=test_9_coch, by="l3", tipo="test")

#@title 12- tiro precios falopa y vuelvo a calcular
train_12_casa = train_11_casa.loc[(train_11_casa["precio_m2"] > 500) & (train_11_casa["precio_m2"]<10000)]
train_12_dpto = train_11_dpto.loc[(train_11_dpto["precio_m2"] > 500) & (train_11_dpto["precio_m2"]<10000)]
train_12_coch = train_11_coch.loc[(train_11_coch["precio_m2"] > 500) & (train_11_coch["precio_m2"]<10000)]

print(f"Tire casa: {sum((train_11_casa['precio_m2'] < 500) | (train_11_casa['precio_m2']>10000))}")
print(f"Tire dpto: {sum((train_11_dpto['precio_m2'] < 500) | (train_11_dpto['precio_m2']>10000))}")
print(f"Tire coch: {sum((train_11_coch['precio_m2'] < 500) | (train_11_coch['precio_m2']>10000))}")

test_12_casa = test_9_casa.copy()
test_12_dpto = test_9_dpto.copy()
test_12_coch = test_9_coch.copy()

train_12_casa = precio_xmxbxp(df_train=train_12_casa, df_test=test_12_casa, by="l3", tipo="train")
test_12_casa = precio_xmxbxp(df_train=train_12_casa, df_test=test_12_casa, by="l3", tipo="test")

train_12_dpto = precio_xmxbxp(df_train=train_12_dpto, df_test=test_12_dpto, by="l3", tipo="train")
test_12_dpto = precio_xmxbxp(df_train=train_12_dpto, df_test=test_12_dpto, by="l3", tipo="test")

train_12_coch = precio_xmxbxp(df_train=train_12_coch, df_test=test_12_coch, by="l3", tipo="train")
test_12_coch = precio_xmxbxp(df_train=train_12_coch, df_test=test_12_coch, by="l3", tipo="test")

#@title 13- sugerencia tomas: tirar los que la diferencia price / sup - precio_xmxbxp <500 o  > 1200
train_13_casa = train_12_casa.loc[abs(train_12_casa["precio_m2"] - train_12_casa["precio_xmxbxp"])  < 2000]
train_13_dpto = train_12_dpto.loc[abs(train_12_dpto["precio_m2"] - train_12_dpto["precio_xmxbxp"])  < 2000]
train_13_coch = train_12_coch.loc[abs(train_12_coch["precio_m2"] - train_12_coch["precio_xmxbxp"])  < 2000]

print(f'Tire casa: {sum(abs(train_12_casa["precio_m2"] - train_12_casa["precio_xmxbxp"])  > 2000)}')
print(f'Tire dpto: {sum(abs(train_12_dpto["precio_m2"] - train_12_dpto["precio_xmxbxp"])  > 2000)}')
print(f'Tire coch: {sum(abs(train_12_coch["precio_m2"] - train_12_coch["precio_xmxbxp"])  > 2000)}')

test_13_casa = test_12_casa.copy()
test_13_dpto = test_12_dpto.copy()
test_13_coch = test_12_coch.copy()

train_13_casa = precio_xmxbxp(df_train=train_13_casa, df_test=test_13_casa, by="l3", tipo="train")
test_13_casa = precio_xmxbxp(df_train=train_13_casa, df_test=test_13_casa, by="l3", tipo="test")

train_13_dpto = precio_xmxbxp(df_train=train_13_dpto, df_test=test_13_dpto, by="l3", tipo="train")
test_13_dpto = precio_xmxbxp(df_train=train_13_dpto, df_test=test_13_dpto, by="l3", tipo="test")

train_13_coch = precio_xmxbxp(df_train=train_13_coch, df_test=test_13_coch, by="l3", tipo="train")
test_13_coch = precio_xmxbxp(df_train=train_13_coch, df_test=test_13_coch, by="l3", tipo="test")

#@title 13- si la diferencia con xmxbxp es más de 1 sigmas lo tiro
diff_casa = train_12_casa["precio_m2"] - train_12_casa["precio_xmxbxp"]
print(train_11_casa.shape)
train_13_casa = train_12_casa[diff_casa.abs() < 1.5*train_12_casa["precio_xmxbxp_std"]]
print(train_13_casa.shape)
diff_dpto = train_12_dpto["precio_m2"] - train_12_dpto["precio_xmxbxp"]
print(train_12_dpto.shape)
train_13_dpto = train_12_dpto[diff_dpto.abs() < 1.5*train_12_dpto["precio_xmxbxp_std"]]
print(train_13_dpto.shape)
diff_coch = train_12_coch["precio_m2"] - train_12_coch["precio_xmxbxp"]
print(train_12_coch.shape)
train_13_coch = train_12_coch[diff_coch.abs() < 1.5*train_12_coch["precio_xmxbxp_std"]]
print(train_13_coch.shape)

# hago una columna que sea precio estimado
def estimo_precio(df):
    df_out = df.copy()
    df_out["precio_estimado"] = df_out.apply(lambda row: row["surface_covered"]*row["precio_xmxbxp"], axis=1)
    # df_out["diferencia"] = df_out.apply(lambda row: row["precio_estimado"] - row["price"], axis=1)
    # df_out["ratio_precio"] = df_out.apply(lambda row: row["price"]/row["surface_covered"]/row["precio_xmxbxp"], axis=1)
    return df_out

#@title 14- estimo precio
train_14_casa = estimo_precio(train_13_casa)
train_14_dpto = estimo_precio(train_13_dpto)
train_14_coch = estimo_precio(train_13_coch)

test_14_casa = estimo_precio(test_13_casa)
test_14_dpto = estimo_precio(test_13_dpto)
test_14_coch = estimo_precio(test_13_coch)

# filtrado_dpto = grafico_4d_lofScore_y_filtroThr(
#     df=calculo_LOF(train_14_dpto, columnas=["rooms", "surface_covered", "diferencia", "price", "precio_estimado"]),
#     x_col="precio_estimado",
#     y_col="price",
#     color_col="surface_covered",
#     size_col="rooms",
#     lof_col="lof_score",
#     thr=0,
# )
# filtrado_dpto

"""# Cosas de titulo"""


#@title 15- dummis
train_15_casa = aplico_dummies(train_14_casa)
train_15_dpto = aplico_dummies(train_14_dpto)
train_15_coch = aplico_dummies(train_14_coch)

test_15_casa = aplico_dummies(test_14_casa)
test_15_dpto = aplico_dummies(test_14_dpto)
test_15_coch = aplico_dummies(test_14_coch)

train_15_casa.groupby("l3")["precio_m2"].describe().round(2).sort_values(by="mean", ascending=False)

"""# Graficos"""

# %%

"""# Entreno CASA

## Acomodo final
"""

train_casa = train_15_casa.copy()
# train_casa = train_15_casa[train_15_casa["inverti_sups"] == False].copy()
train_casa = train_casa.dropna(subset=["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "price", "categoria", "sup_x_room", "total-cov", "precio_xmxbxp", "precio_m2", "precio_estimado"])

#@title completo nans que hayan quedado
train_casa["invierto_bed_room"] = train_casa["invierto_bed_room"].fillna(False)
train_casa["corrijo_room_con_bed+1"] = train_casa["corrijo_room_con_bed+1"].fillna(False)
train_casa["corrijo_bathrooms"] = train_casa["corrijo_bathrooms"].fillna(False)
# train_casa["corrijo_monoambiente"] = train_casa["corrijo_monoambiente"].fillna(False)

train_casa["corrijo_bedroom"] = train_casa["corrijo_bedroom"].fillna(False)
train_casa["corrijo_room"] = train_casa["corrijo_room"].fillna(False)
train_casa["inverti_sups"] = train_casa["inverti_sups"].fillna(False)
train_casa["surface_total_inflado"] = train_casa["surface_total_inflado"].fillna(False)
train_casa["surface_covered_inflado"] = train_casa["surface_covered_inflado"].fillna(False)
train_casa["surface_totalycov_inflado"] = train_casa["surface_totalycov_inflado"].fillna(False)

# Transformaciones de ultimo momento
train_casa["sup_ratio"] = train_casa["surface_total"]/train_casa["surface_covered"]
train_casa["len_description"] = train_casa.apply(lambda row: len(row["description"]), axis=1)
train_casa["room_ratio"] = train_casa["rooms"] / train_casa["bedrooms"]

#@title preparo datos
predictores = [
    #'ad_type', 'start_date', 'end_date', 'created_on',
    'lat', 'lon',
    #'l1', 'l2', 'l3', 'l4', 'l5', 'l6',
    #'rooms', 'bedrooms', 'bathrooms',
    # 'surface_total',
    'surface_covered',
    #'currency', 'price_period', 'title', 'description', 'property_type', 'operation_type',

    # TRANSFORMS
    # 'mean_lat', 'mean_lon',
    'sfc_x_bath', 'sup_x_room', 'total-cov',
    # 'room-bed',
    'precio_xmxbxp', 'precio_xmxbxp_std',
    # "ratio_precio",
    # 'precio_estimado',
    # 'categoria',
    'sup_ratio', 'len_description', 'room_ratio',

    # FLAGS
    # 'en_pesos',
    'corrijo_latlon',
    # 'corrijo_barrio',
    # 'es_Casa', 'es_Cochera', 'es_Departamento',
    # 'surface_totalycov_inflado', 'surface_total_inflado', 'surface_covered_inflado', 'inverti_sups',
    # 'corrijo_room', 'corrijo_bedroom',
    # 'invierto_bed_room','corrijo_room_con_bed+1',
    # 'corrijo_bathrooms',
    #'corrijo_monoambiente',

    # DUMMIES
    # "a_refaccionar",
    "lujos",
    # "a_nuevo", "duplex",
    "es_PuertoMadero",
    # "barrio_BELGRANO",
    # "barrio_PALERMO",
    # "es_cheto",
]



prediccion = "price"
# prediccion = "ratio_precio"

train = train_casa.copy()

df_train_casa = train[predictores + [prediccion]]
df_train_casa = df_train_casa.replace([np.inf, -np.inf], np.nan)

# df_train_casa = df_train_casa.dropna()

X = df_train_casa[predictores]
y = df_train_casa[prediccion]

predictores

ver_correlaciones(df_train_casa[predictores + [prediccion]], figsize=(18, 12))

# Commented out IPython magic to ensure Python compatibility.
from sklearn.model_selection import cross_val_score, KFold

# @title `entrenar_modelo`

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.1, random_state=42
)
print("Entreno con columnas: ", X_train.columns)

print("X_train", X_train.shape)
print("X_test", X_test.shape)
print("y_train", y_train.shape)
print("y_test", y_test.shape)


results = {
    "estimators": [],
    "max_depth": [],
    "min_samples_split": [],
    "min_samples_leaf": [],
    "score": [],
}

for n_estimators in [500]: #[500]:
    for max_depth in [30]:
        for min_samples_split in [2]: #[5]:
            for min_samples_leaf in [2]: #[3]:
                reg = RandomForestRegressor(
                    n_estimators=n_estimators, max_depth=max_depth, min_samples_split=min_samples_split, min_samples_leaf=min_samples_leaf, n_jobs=-1, random_state=42
                )

            ### NO CAMBIAR RandomForestRegressor por otro modelo
            ### NOTA: Si en la primera entrega usan otro modelo, su nota será 0
            ### Pueden cambiar los hiperparámetros que afectan al árbol: n_estimators, criterion, max_depth, min_samples_split, min_samples_leaf, min_weight_fraction_leaf, max_features, max_leaf_nodes, min_impurity_decrease

                # Entrenamos el modelo
#                 %time _ = reg.fit(X_train, y_train)

                # Cálculo del error en entrenamiento (train)
#                 %time y_pred = reg.predict(X_train)
                score_train = root_mean_squared_error(y_train, y_pred)

                # Cálculo del error en prueba (test)
                y_pred = reg.predict(X_test)
                score_test = root_mean_squared_error(y_test, y_pred)

                now = datetime.now().strftime('%m%d - %H%M%S')
                # print(f"{now} {n_estimators=}, {max_depth=}, {min_samples_split=}, {min_samples_leaf=} --> {scores_mean=:.2f} - {scores_std=:.2f}")

                results["estimators"].append(n_estimators)
                results["max_depth"].append(max_depth)
                results["min_samples_split"].append(min_samples_split)
                results["min_samples_leaf"].append(min_samples_leaf)
                # results["score"].append(scores)


#%%

plot_pred_vs_true_interactivo(y_test, y_pred, name="")

score_test

#@title Importancia de features

importances = reg.feature_importances_
feature_names = X_train.columns

# Convertir a DataFrame para ordenar y graficar
importancia_df = pd.DataFrame({
    'feature': feature_names,
    'importance': importances
}).sort_values(by='importance', ascending=False)

print(importancia_df.round(3))

# Gráfico opcional
importancia_df.head(20).plot(kind='barh', x='feature', y='importance', figsize=(8,6), title='Importancia de Variables')
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()

#@title Analisis de error
if prediccion == "price":
    X_test["error"] = abs(y_pred - y_test)
    X_test["price"] = y_test
    X_test["pred_price"] = y_pred
    X_test["error_relativo"] = X_test["error"]/y_test
    X_test["barrio"] = train_casa.loc[X_test.index, "l3"]

X_test.sort_values(by="error", ascending=False).round(2).head(30)

train_casa.loc[253561]

top_errores = X_test.sort_values(by="error", ascending=False).head(30)

barrio_mas_frec = top_errores["barrio"].mode().iloc[0]  # barrio más frecuente
frecuencia = top_errores["barrio"].value_counts().iloc[0]  # cuántas veces aparece
print("Resumen de los 30 casos con mayor error:")
print("Barrio más frecuente:", barrio_mas_frec, f"(aparece {frecuencia} veces)")

top_errores.select_dtypes(include="number").describe().round(2)

train_casa.loc[44991, "description"]

test_casa = test_15_casa.copy()
df_test_casa = test_casa.copy()

# Transformaciones de ultimo momento
df_test_casa["sup_ratio"] = df_test_casa["surface_total"]/df_test_casa["surface_covered"]
df_test_casa["len_description"] = df_test_casa.apply(lambda row: len(row["description"]), axis=1)
df_test_casa["room_ratio"] = df_test_casa["rooms"] / df_test_casa["bedrooms"]

nans_x_columna(df_test_casa[predictores])

#@title completo nans que hayan quedado
df_test_casa["room_ratio"] = df_test_casa["room_ratio"].fillna(0)
df_test_casa["categoria"] = df_test_casa["categoria"].fillna(0)
df_test_casa["sfc_x_bath"] = df_test_casa["sfc_x_bath"].fillna(0)
df_test_casa["sup_x_room"] = df_test_casa["sup_x_room"].fillna(0)
df_test_casa["total-cov"] = df_test_casa["total-cov"].fillna(0)
df_test_casa["precio_xmxbxp"] = df_test_casa["precio_xmxbxp"].fillna(df_test_casa["precio_xmxbxp"].median())
df_test_casa["precio_xmxbxp_std"] = df_test_casa["precio_xmxbxp_std"].fillna(df_test_casa["precio_xmxbxp_std"].median())
df_test_casa["lat"] = df_test_casa["lat"].fillna(df_test_casa["lat"].median())
df_test_casa["lon"] = df_test_casa["lon"].fillna(df_test_casa["lon"].median())




# df_test_casa["invierto_bed_room"] = df_test_casa["invierto_bed_room"].fillna(False)
# df_test_casa["corrijo_room_con_bed+1"] = df_test_casa["corrijo_room_con_bed+1"].fillna(False)
# df_test_casa["corrijo_bathrooms"] = df_test_casa["corrijo_bathrooms"].fillna(False)
# # df_test_casa["corrijo_monoambiente"] = df_test_casa["corrijo_monoambiente"].fillna(False)

# df_test_casa["corrijo_bedroom"] = df_test_casa["corrijo_bedroom"].fillna(False)
# df_test_casa["corrijo_room"] = df_test_casa["corrijo_room"].fillna(False)
# df_test_casa["inverti_sups"] = df_test_casa["inverti_sups"].fillna(False)
# df_test_casa["surface_total_inflado"] = df_test_casa["surface_total_inflado"].fillna(False)
# df_test_casa["surface_covered_inflado"] = df_test_casa["surface_covered_inflado"].fillna(False)
# df_test_casa["surface_totalycov_inflado"] = df_test_casa["surface_totalycov_inflado"].fillna(False)

# Commented out IPython magic to ensure Python compatibility.
# %%
#@title This is it
from datetime import datetime
X = df_train_casa[predictores]
y = df_train_casa[prediccion]

# Entrenamos el modelo con todos los datos de entrenamiento.csv
# %time reg.fit(X, y)

# X_ap = df_test_final[X.columns]

#@title predigo
X_ap = df_test_casa[reg.feature_names_in_]

# Predecimos los precios del dataset a predecir
y_pred_ap = reg.predict(X_ap)
y_pred_ap

# Lleno el precio de df_ap con las predicciones
df_test_casa["price"] = y_pred_ap

test_casa.loc[283802]#, "description"]

"""# Entreno Dpto + Cochera"""

train_15_dpto.groupby("l3")["precio_m2"].describe().round(2).sort_values(by="mean", ascending=False)

"""## Acomodo final"""

train_dpto = pd.concat([train_15_dpto, train_15_coch])
train_dpto = train_dpto.dropna(subset=["rooms", "bedrooms", "bathrooms", "surface_total", "surface_covered", "price", "categoria", "sup_x_room", "total-cov", "precio_xmxbxp", "precio_m2", "precio_estimado"])

train_dpto["invierto_bed_room"] = train_dpto["invierto_bed_room"].fillna(False)
train_dpto["corrijo_room_con_bed+1"] = train_dpto["corrijo_room_con_bed+1"].fillna(False)
train_dpto["corrijo_bathrooms"] = train_dpto["corrijo_bathrooms"].fillna(False)
train_dpto["corrijo_monoambiente"] = train_dpto["corrijo_monoambiente"].fillna(False)

train_dpto["corrijo_bedroom"] = train_dpto["corrijo_bedroom"].fillna(False)
train_dpto["corrijo_room"] = train_dpto["corrijo_room"].fillna(False)
train_dpto["inverti_sups"] = train_dpto["inverti_sups"].fillna(False)
train_dpto["surface_total_inflado"] = train_dpto["surface_total_inflado"].fillna(False)
train_dpto["surface_covered_inflado"] = train_dpto["surface_covered_inflado"].fillna(False)
train_dpto["surface_totalycov_inflado"] = train_dpto["surface_totalycov_inflado"].fillna(False)

train_dpto["sup_ratio"] = train_dpto["surface_total"]/train_dpto["surface_covered"]
train_dpto["len_description"] = train_dpto.apply(lambda row: len(row["description"]), axis=1)
train_dpto["room_ratio"] = train_dpto["rooms"] / train_dpto["bedrooms"]

#@title preparo datos
predictores = [
    #'ad_type', 'start_date', 'end_date', 'created_on',
    'lat', 'lon',
    #'l1', 'l2', 'l3', 'l4', 'l5', 'l6',
    # 'rooms',
    # 'bedrooms',
    # 'bathrooms',  'surface_total',
    'surface_covered',
    #'currency', 'price_period', 'title', 'description', 'property_type', 'operation_type',

    # TRANSFORMS
    # 'mean_lat', 'mean_lon',
    'sfc_x_bath', 'sup_x_room', 'total-cov',
    # 'room-bed',
    'precio_xmxbxp', 'precio_xmxbxp_std',
    # "ratio_precio",
    # 'precio_estimado',
    'categoria', 'sup_ratio', 'len_description', 'room_ratio',

    # FLAGS
    # 'en_pesos', 'corrijo_latlon', 'corrijo_barrio',
    # 'es_Cochera', 'es_Departamento',
    # 'surface_totalycov_inflado', 'surface_total_inflado', 'surface_covered_inflado', 'inverti_sups',
    # 'corrijo_room', 'corrijo_bedroom', 'invierto_bed_room','corrijo_room_con_bed+1',
    # 'corrijo_bathrooms', 'corrijo_monoambiente',

    # DUMMIES
    # "a_refaccionar",
    "lujos",
    "a_nuevo", "duplex",
    "es_PuertoMadero",
    # "es_cheto"
    ]

prediccion = "price"
# prediccion = "ratio_precio"

